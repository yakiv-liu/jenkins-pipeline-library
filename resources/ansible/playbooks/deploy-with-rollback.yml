---
- name: 部署应用并支持自动回滚
  hosts: all
  vars:
    app_name: "{{ project_name }}"
    backup_dir: "{{ backup_dir | default('/opt/backups') }}"
    max_backups: 10
    health_check_timeout: 300
    health_check_interval: 10
    target_host: "{{ ansible_host }}"

  tasks:
    - name: 创建备份目录
      file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0755'

    - name: 创建应用目录
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: 检查当前运行版本
      shell: |
        docker ps --filter "name={{ app_name }}" --format "{{ '{{' }}.Image{{ '}}' }}" 2>/dev/null | head -1 || echo "none"
      register: current_version
      changed_when: false

    - name: 备份当前部署配置
      when: current_version.stdout != "none"
      shell: |
        cat > "{{ backup_dir }}/{{ app_name }}-backup-$(date +%s).yml" << EOF
        app_name: {{ app_name }}
        current_version: "{{ current_version.stdout | regex_replace('.*:', '') | default('unknown') }}"
        backup_time: "$(date -Iseconds)"
        environment: "{{ deploy_env }}"
        EOF
      args:
        executable: '/bin/bash'

    - name: 拉取新版本镜像
      shell: |
        docker pull "{{ harbor_url }}/{{ app_name }}:{{ app_version }}"
      args:
        executable: '/bin/bash'

    - name: 部署新版本
      block:
        - name: 停止当前容器
          docker_container:
            name: "{{ app_name }}"
            state: absent
          ignore_errors: yes

        - name: 启动新容器
          docker_container:
            name: "{{ app_name }}"
            image: "{{ harbor_url }}/{{ app_name }}:{{ app_version }}"
            state: started
            restart_policy: always
            ports:
              - "{{ app_port }}:8080"
            env:
              SPRING_PROFILES_ACTIVE: "{{ deploy_env }}"
              JAVA_OPTS: "-Xmx512m -Xms256m -Dapp.version={{ app_version }} -Dapp.env={{ deploy_env }}"
              APP_VERSION: "{{ app_version }}"
              GIT_COMMIT: "{{ git_commit | default('unknown') }}"
            memory: 512m
            cpus: 0.5

        # === 修改点：修复模板冲突，使用单引号和转义 ===
        - name: 检查容器状态
          shell: |
            docker ps -a --filter "name={{ app_name }}" --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
          register: container_status
          failed_when: false

        - name: 显示容器状态
          debug:
            var: container_status.stdout

        # === 修改点：添加应用程序启动等待 ===
        - name: 等待应用程序启动（初次等待）
          wait_for:
            delay: 10
          when: "'Up' in container_status.stdout"

        # === 修改点：改进等待逻辑，先检查容器内进程 ===
        - name: 检查应用程序进程
          shell: |
            # 等待应用程序在容器内启动
            for i in {1..30}; do
              if docker exec "{{ app_name }}" ps aux | grep java > /dev/null 2>&1; then
                echo "应用程序已启动"
                exit 0
              fi
              sleep 2
            done
            echo "应用程序启动超时"
            exit 1
          register: app_process_check
          failed_when: app_process_check.rc != 0
          when: "'Up' in container_status.stdout"

        - name: 显示应用程序进程检查结果
          debug:
            var: app_process_check.stdout

        # === 修改点：改进端口等待逻辑 ===
        - name: 等待容器端口可用
          wait_for:
            port: "{{ app_port }}"
            host: "{{ target_host }}"
            delay: 5
            timeout: 120  # 增加超时时间到2分钟
            state: started

        - name: 健康检查
          uri:
            url: "http://{{ target_host }}:{{ app_port }}/health"
            method: GET
            return_content: yes
            status_code: 200
            timeout: 30
          register: health_result
          until: health_result.status == 200
          retries: "{{ (health_check_timeout / health_check_interval) | int }}"
          delay: "{{ health_check_interval }}"

        - name: 验证版本信息
          uri:
            url: "http://{{ target_host }}:{{ app_port }}/info"
            method: GET
            return_content: yes
            status_code: 200
          register: info_result
          failed_when:
            - info_result.status != 200
            - "'{{ app_version }}' not in info_result.content"

      rescue:
        - name: 部署失败 - 执行自动回滚
          debug:
            msg: "部署失败，开始执行自动回滚..."

        - name: 收集容器诊断信息
          block:
            - name: 检查最终容器状态
              shell: |
                docker ps -a --filter "name={{ app_name }}" || echo "容器不存在"
              register: final_container_status
              failed_when: false

            - name: 显示最终容器状态
              debug:
                var: final_container_status.stdout

            - name: 获取容器日志
              shell: |
                docker logs "{{ app_name }}" --tail 100 || echo "无法获取日志"
              register: final_container_logs
              failed_when: false

            - name: 显示容器日志
              debug:
                var: final_container_logs.stdout

            - name: 检查容器内进程
              shell: |
                docker exec "{{ app_name }}" ps aux || echo "无法执行进程检查"
              register: container_processes
              failed_when: false

            - name: 显示容器进程
              debug:
                var: container_processes.stdout

            - name: 检查端口监听
              shell: |
                netstat -tuln | grep "{{ app_port }}" || ss -tuln | grep "{{ app_port }}" || echo "端口未监听"
              register: port_listening
              failed_when: false

            - name: 显示端口监听状态
              debug:
                var: port_listening.stdout

          rescue:
            - name: 诊断信息收集失败
              debug:
                msg: "无法收集完整的诊断信息"

        - name: 停止失败容器
          docker_container:
            name: "{{ app_name }}"
            state: absent
          ignore_errors: yes

        - name: 查找最新备份版本
          find:
            paths: "{{ backup_dir }}"
            patterns: "{{ app_name }}-backup-*.yml"
          register: available_backups

        - name: 从备份文件获取回滚版本号
          when: available_backups.files | length > 0
          include_vars:
            file: "{{ (available_backups.files | sort(attribute='mtime') | last).path }}"

        - name: 启动回滚版本
          when: current_version is defined and current_version.stdout != "none"
          docker_container:
            name: "{{ app_name }}"
            image: "{{ current_version.stdout }}"
            state: started
            restart_policy: always
            ports:
              - "{{ app_port }}:8080"
            env:
              SPRING_PROFILES_ACTIVE: "{{ deploy_env }}"

        - name: 等待回滚容器启动
          wait_for:
            port: "{{ app_port }}"
            host: "{{ target_host }}"
            delay: 5
            timeout: 60

        - name: 验证回滚成功
          when: current_version is defined and current_version.stdout != "none"
          uri:
            url: "http://{{ target_host }}:{{ app_port }}/health"
            method: GET
            return_content: yes
            status_code: 200
          register: rollback_health
          until: rollback_health.status == 200
          retries: 12
          delay: 5

        - name: 记录回滚操作
          shell: |
            cat > "{{ backup_dir }}/{{ app_name }}-rollback-$(date +%s).yml" << EOF
            rollback_time: "$(date -Iseconds)"
            failed_version: "{{ app_version }}"
            rollback_version: "{{ current_version.stdout }}"
            environment: "{{ deploy_env }}"
            reason: "Deployment failed, auto-rollback triggered"
            EOF
          args:
            executable: '/bin/bash'

        - name: 抛出回滚完成异常
          fail:
            msg: "部署失败，已自动回滚到上一个稳定版本"

    - name: 清理旧备份
      find:
        paths: "{{ backup_dir }}"
        patterns: "{{ app_name }}-backup-*.yml"
      register: backup_files

    - name: 保留最新备份文件
      when: backup_files.files | length > max_backups
      file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ backup_files.files | sort(attribute='mtime') | list | slice(0, backup_files.files | length - max_backups) }}"