---
- name: 部署应用并支持自动回滚
  hosts: all
  vars:
    app_name: "{{ project_name }}"
    backup_dir: "{{ backup_dir | default('/opt/backups') }}"
    max_backups: 10
    health_check_timeout: 300
    health_check_interval: 10
    target_host: "{{ ansible_host }}"

  tasks:
    - name: 创建备份目录
      file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0755'

    - name: 创建应用目录
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: 检查当前运行版本
      shell: |
        docker ps --filter "name={{ app_name }}" --format "{{ '{{' }}.Image{{ '}}' }}" 2>/dev/null | head -1 || echo "none"
      register: current_version
      changed_when: false

    - name: 备份当前部署配置
      when: current_version.stdout != "none"
      shell: |
        cat > "{{ backup_dir }}/{{ app_name }}-backup-$(date +%s).yml" << EOF
        app_name: {{ app_name }}
        current_version: "{{ current_version.stdout | regex_replace('.*:', '') | default('unknown') }}"
        backup_time: "$(date -Iseconds)"
        environment: "{{ deploy_env }}"
        EOF
      args:
        executable: '/bin/bash'

    - name: 拉取新版本镜像
      shell: |
        docker pull "{{ harbor_url }}/{{ app_name }}:{{ app_version }}"
      args:
        executable: '/bin/bash'

    - name: 部署新版本
      block:
        - name: 停止当前容器
          docker_container:
            name: "{{ app_name }}"
            state: absent
          ignore_errors: yes

        - name: 启动新容器
          docker_container:
            name: "{{ app_name }}"
            image: "{{ harbor_url }}/{{ app_name }}:{{ app_version }}"
            state: started
            restart_policy: always
            ports:
              - "{{ app_port }}:8080"
            env:
              SPRING_PROFILES_ACTIVE: "{{ deploy_env }}"
              JAVA_OPTS: "-Xmx512m -Xms256m -Dapp.version={{ app_version }} -Dapp.env={{ deploy_env }}"
              APP_VERSION: "{{ app_version }}"
              GIT_COMMIT: "{{ git_commit | default('unknown') }}"
            memory: 512m
            cpus: 0.5

        - name: 检查容器是否运行
          shell: |
            docker inspect --format='{{ '{{' }}.State.Running{{ '}}' }}' "{{ app_name }}" 2>/dev/null || echo "false"
          register: container_running
          changed_when: false

        - name: 显示容器运行状态
          debug:
            var: container_running.stdout

        - name: 等待应用程序启动
          wait_for:
            delay: 15

        - name: 测试应用程序是否响应
          shell: |
            for i in {1..10}; do
              if curl -f -s -o /dev/null -w "%{http_code}" "http://localhost:{{ app_port }}/hello" | grep -q "200"; then
                echo "应用程序已就绪"
                exit 0
              fi
              sleep 3
            done
            echo "应用程序启动超时"
            exit 1
          register: app_ready_check
          failed_when: app_ready_check.rc != 0

        - name: 显示应用程序就绪状态
          debug:
            var: app_ready_check.stdout

        - name: 验证部署成功
          debug:
            msg: "部署成功！应用程序已启动并响应"

      rescue:
        - name: 部署失败 - 执行自动回滚
          debug:
            msg: "部署失败，开始执行自动回滚..."

        - name: 收集容器诊断信息
          block:
            - name: 检查最终容器状态
              shell: |
                docker ps -a --filter "name={{ app_name }}" || echo "容器不存在"
              register: final_container_status
              failed_when: false

            - name: 显示最终容器状态
              debug:
                var: final_container_status.stdout

            - name: 获取容器日志
              shell: |
                docker logs "{{ app_name }}" --tail 50 || echo "无法获取日志"
              register: final_container_logs
              failed_when: false

            - name: 显示容器日志
              debug:
                var: final_container_logs.stdout

            - name: 测试应用程序端点
              shell: |
                curl -f -m 5 "http://localhost:{{ app_port }}/hello" || echo "端点不可用"
              register: endpoint_test
              failed_when: false

            - name: 显示端点测试结果
              debug:
                var: endpoint_test.stdout

          rescue:
            - name: 诊断信息收集失败
              debug:
                msg: "无法收集完整的诊断信息"

        - name: 停止失败容器
          docker_container:
            name: "{{ app_name }}"
            state: absent
          ignore_errors: yes

        - name: 查找最新备份版本
          find:
            paths: "{{ backup_dir }}"
            patterns: "{{ app_name }}-backup-*.yml"
          register: available_backups

        - name: 从备份文件获取回滚版本号
          when: available_backups.files | length > 0
          include_vars:
            file: "{{ (available_backups.files | sort(attribute='mtime') | last).path }}"

        - name: 启动回滚版本
          when: current_version is defined and current_version.stdout != "none"
          docker_container:
            name: "{{ app_name }}"
            image: "{{ current_version.stdout }}"
            state: started
            restart_policy: always
            ports:
              - "{{ app_port }}:8080"
            env:
              SPRING_PROFILES_ACTIVE: "{{ deploy_env }}"

        - name: 等待回滚应用程序启动
          wait_for:
            delay: 15

        - name: 验证回滚成功
          when: current_version is defined and current_version.stdout != "none"
          shell: |
            curl -f -s "http://localhost:{{ app_port }}/hello" && echo "回滚成功" || echo "回滚失败"
          register: rollback_test
          failed_when: rollback_test.rc != 0

        - name: 记录回滚操作
          shell: |
            cat > "{{ backup_dir }}/{{ app_name }}-rollback-$(date +%s).yml" << EOF
            rollback_time: "$(date -Iseconds)"
            failed_version: "{{ app_version }}"
            rollback_version: "{{ current_version.stdout }}"
            environment: "{{ deploy_env }}"
            reason: "Deployment failed, auto-rollback triggered"
            EOF
          args:
            executable: '/bin/bash'

        - name: 抛出回滚完成异常
          fail:
            msg: "部署失败，已自动回滚到上一个稳定版本"

    - name: 清理旧备份
      find:
        paths: "{{ backup_dir }}"
        patterns: "{{ app_name }}-backup-*.yml"
      register: backup_files

    # === 修改点：修复除零错误，使用更安全的清理逻辑 ===
    - name: 保留最新备份文件
      when: backup_files.files | length > max_backups
      file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ backup_files.files | sort(attribute='mtime') | list[0: (backup_files.files | length - max_backups) | int] }}"